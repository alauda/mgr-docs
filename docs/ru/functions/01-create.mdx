---
weight: 1
sourceSHA: 1c89c1c862e93b44cfdd5adf0cc2982f830b65a853cb0c39f580bf0177ed1ddc
---

# Создание экземпляра

## Обзор функции

Создавайте и управляйте экземплярами базы данных MySQL-MGR в кластере Kubernetes. Быстро разверните кластер репликации MySQL, соответствующий вашим требованиям, настроив спецификации ресурсов, шаблоны параметров, информацию об учетной записи и другие параметры.

## Требования

- Убедитесь, что оператор MySQL-MGR установлен в кластере.
- Убедитесь, что класс хранения кластера поддерживает динамическое предоставление объемов (рекомендуется TopoLVM).
- Убедитесь, что имеются достаточные квоты ресурсов.

## Процедура

<Tabs>
  <Tab label="CLI">
    1. Создание пароля

    ```bash
    kubectl -n ${namespace} create secret generic mgr-${instance_name}-password \
    --from-literal=clusterchecker={password} \
    --from-literal=exporter=${password} \
    --from-literal=manage=${password} \
    --from-literal=root=${password}
    ```

    ::: info

    - `${instance_name}` — это имя экземпляра, используемое для его идентификации и должно быть уникальным.
    - `${namespace}` — это пространство имен, к которому принадлежит экземпляр.
    - `${password}` — это пароль, для разных пользователей можно задать различные пароли.

    :::

    2. Создание экземпляра CR

    ```bash
    kubectl apply -n $namespace -f - <<EOF
    apiVersion: middleware.alauda.io/v1
    kind: Mysql
    metadata:
      labels:
        mysql/arch: mgr
      name: ${instance_name}
    spec:
      mgr:
        enableStorage: true
        members: 3
        monitor:
          enable: true
        resources:
          server:
            limits:
              cpu: "2"
              memory: 4Gi
            requests:
              cpu: "2"
              memory: 4Gi
        router:
          replicas: 2
          resources:
            limits:
              cpu: 800m
              memory: 640Mi
            requests:
              cpu: 800m
              memory: 640Mi
          svcRO:
            type: ClusterIP
          svcRW:
            type: ClusterIP
        volumeClaimTemplate:
          spec:
            resources:
              requests:
                storage: 20Gi
            storageClassName: sc-topolvm
      params:
        mysql:
          mysqld:
            binlog_expire_logs_seconds: "604800"
            binlog_format: ROW
            character_set_server: utf8mb4
            default_storage_engine: InnoDB
            default_time_zone: +08:00
            disabled_storage_engines: MyISAM
            event_scheduler: ВКЛ
            general_log: ВЫКЛ
            innodb_adaptive_flushing: ВКЛ
            innodb_adaptive_hash_index: ВЫКЛ
            innodb_autoinc_lock_mode: "2"
            innodb_buffer_pool_chunk_size: "134217728"
            innodb_buffer_pool_dump_at_shutdown: ВКЛ
            innodb_buffer_pool_dump_pct: "25"
            innodb_buffer_pool_instances: "2"
            innodb_buffer_pool_load_abort: ВЫКЛ
            innodb_buffer_pool_load_at_startup: ВКЛ
            innodb_buffer_pool_size: 1536M
            innodb_deadlock_detect: ВКЛ
            innodb_disable_sort_file_cache: ВЫКЛ
            innodb_fast_shutdown: "1"
            innodb_file_per_table: ВКЛ
            innodb_flush_log_at_trx_commit: "1"
            innodb_flush_method: O_DIRECT_NO_FSYNC
            innodb_flush_neighbors: "0"
            innodb_io_capacity: "4000"
            innodb_io_capacity_max: "4294967295"
            innodb_max_purge_lag: "0"
            innodb_max_undo_log_size: "1073741824"
            innodb_online_alter_log_max_size: "134217728"
            innodb_page_cleaners: "4"
            innodb_purge_batch_size: "600"
            innodb_purge_rseg_truncate_frequency: "128"
            innodb_purge_threads: "4"
            innodb_read_io_threads: "4"
            innodb_redo_log_capacity: 1G
            innodb_rollback_segments: "128"
            innodb_strict_mode: ВКЛ
            innodb_thread_concurrency: "5"
            innodb_undo_log_truncate: ВКЛ
            innodb_write_io_threads: "4"
            interactive_timeout: "3600"
            log_bin: bin
            log_bin_trust_function_creators: ВЫКЛ
            log_output: FILE
            loose_group_replication_communication_max_message_size: "10485760"
            loose_group_replication_exit_state_action: READ_ONLY
            loose_group_replication_flow_control_applier_threshold: "1000"
            loose_group_replication_flow_control_certifier_threshold: "1000"
            loose_group_replication_member_expel_timeout: "5"
            loose_group_replication_message_cache_size: 256M
            loose_group_replication_paxos_single_leader: ВКЛ
            loose_group_replication_poll_spin_loops: "0"
            loose_group_replication_transaction_size_limit: "150000000"
            loose_group_replication_unreachable_majority_timeout: "0"
            loose_group_replication_xcom_ssl_accept_retries: "10"
            max_allowed_packet: "67108864"
            max_binlog_size: "1073741824"
            max_connect_errors: "1000000"
            max_connections: "512"
            max_heap_table_size: 16M
            max_prepared_stmt_count: "8192"
            performance_schema: ВКЛ
            replica_parallel_type: LOGICAL_CLOCK
            replica_parallel_workers: "4"
            skip_external_locking: ВКЛ
            skip_name_resolve: ВКЛ
            sort_buffer_size: "262144"
            sql_generate_invisible_primary_key: ВКЛ
            sql_mode: NO_ENGINE_SUBSTITUTION
            sync_binlog: "1"
            table_definition_cache: "2000"
            table_open_cache_instances: "16"
            thread_handling: pool-of-threads
            thread_pool_max_threads: "128"
            thread_pool_oversubscribe: "32"
            thread_pool_size: "2"
            tmp_table_size: 16M
            wait_timeout: "3600"
        router:
          DEFAULT:
            max_total_connections: "300"
          logger:
            level: info
      upgradeOption:
        autoUpgrade: false
      version: "8.0"
    EOF
    ```

    3. Проверьте состояние экземпляра

    ```bash
    kubectl get mysql -n {namespace} {instance_name} -w
    ```
  </Tab>

  <Tab label="Веб-консоль">
    1. Выберите **MySQL-MGR** в левой панели навигации.
    2. Введите целевое пространство имен.
    3. Нажмите **Создать экземпляр**.
    4. Настройте основные параметры:

    - Имя экземпляра: уникальный идентификатор
    - Конфигурация архитектуры: Один мастер (по умолчанию) / Мульти-мастер

    5. Конфигурация ресурсов:

    - Количество реплик: рекомендуется начинать с 3 узлов
    - Спецификации: запросы и пределы значений CPU/Память для участников MySQL
    - Класс хранения: выберите класс хранения типа TopoLVM
    - Размер хранилища: оцените потребности в хранилище на основе бизнес-требований

    6. Ресурсы учетной записи:

    - Настройте пароль администратора root.

    7. Конфигурация подключения:

    - Метод доступа: Внешний доступ / Внутренний доступ

    8. Нажмите **Создать** и дождитесь изменения статуса на "Запущено".
  </Tab>
</Tabs>
