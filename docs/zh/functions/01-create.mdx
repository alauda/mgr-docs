---
weight: 1
---
# 创建实例

## 功能简介
在Kubernetes集群中创建和管理MySQL-MGR数据库实例。通过配置资源规格、参数模板、账户信息等参数，快速部署符合需求的MySQL Group Replication集群。

## 前提条件
- 确保集群已安装MySQL-MGR Operator
- 集群存储类支持动态卷供应（推荐TopoLVM）
- 确保有足够的资源配额

## 操作步骤
<Tabs>
    <Tab label="命令行操作">
        1. 创建密码
        ```bash
        kubectl -n ${namespace} create secret generic mgr-${instance_name}-password \
        --from-literal=clusterchecker={password} \
        --from-literal=exporter=${password} \
        --from-literal=manage=${password} \
        --from-literal=root=${password}
        ```

        ::: info

        - `${instance_name}` 为实例名称，用于标识实例，不可重复。
        - `${namespace}` 为实例所属的命名空间
        - `${password}` 为密码，上面多个用户可以分别设置不同的密码

        :::

        2. 创建实例CR
        ```bash
        kubectl apply -n $namespace -f - <<EOF
apiVersion: middleware.alauda.io/v1
kind: Mysql
metadata:
  labels:
    mysql/arch: mgr
  name: ${instance_name}
spec:
  mgr:
    enableStorage: true
    members: 3
    monitor:
      enable: true
    resources:
      server:
        limits:
          cpu: "2"
          memory: 4Gi
        requests:
          cpu: "2"
          memory: 4Gi
    router:
      replicas: 2
      resources:
        limits:
          cpu: 800m
          memory: 640Mi
        requests:
          cpu: 800m
          memory: 640Mi
      svcRO:
        type: ClusterIP
      svcRW:
        type: ClusterIP
    volumeClaimTemplate:
      spec:
        resources:
          requests:
            storage: 20Gi
        storageClassName: sc-topolvm
  params:
    mysql:
      mysqld:
        binlog_expire_logs_seconds: "604800"
        binlog_format: ROW
        character_set_server: utf8mb4
        default_storage_engine: InnoDB
        default_time_zone: +08:00
        disabled_storage_engines: MyISAM
        event_scheduler: ON
        general_log: OFF
        innodb_adaptive_flushing: ON
        innodb_adaptive_hash_index: OFF
        innodb_autoinc_lock_mode: "2"
        innodb_buffer_pool_chunk_size: "134217728"
        innodb_buffer_pool_dump_at_shutdown: ON
        innodb_buffer_pool_dump_pct: "25"
        innodb_buffer_pool_instances: "2"
        innodb_buffer_pool_load_abort: OFF
        innodb_buffer_pool_load_at_startup: ON
        innodb_buffer_pool_size: 1536M
        innodb_deadlock_detect: ON
        innodb_disable_sort_file_cache: OFF
        innodb_fast_shutdown: "1"
        innodb_file_per_table: ON
        innodb_flush_log_at_trx_commit: "1"
        innodb_flush_method: O_DIRECT_NO_FSYNC
        innodb_flush_neighbors: "0"
        innodb_io_capacity: "4000"
        innodb_io_capacity_max: "4294967295"
        innodb_max_purge_lag: "0"
        innodb_max_undo_log_size: "1073741824"
        innodb_online_alter_log_max_size: "134217728"
        innodb_page_cleaners: "4"
        innodb_purge_batch_size: "600"
        innodb_purge_rseg_truncate_frequency: "128"
        innodb_purge_threads: "4"
        innodb_read_io_threads: "4"
        innodb_redo_log_capacity: 1G
        innodb_rollback_segments: "128"
        innodb_strict_mode: ON
        innodb_thread_concurrency: "5"
        innodb_undo_log_truncate: ON
        innodb_write_io_threads: "4"
        interactive_timeout: "3600"
        log_bin: bin
        log_bin_trust_function_creators: OFF
        log_output: FILE
        loose_group_replication_communication_max_message_size: "10485760"
        loose_group_replication_exit_state_action: READ_ONLY
        loose_group_replication_flow_control_applier_threshold: "1000"
        loose_group_replication_flow_control_certifier_threshold: "1000"
        loose_group_replication_member_expel_timeout: "5"
        loose_group_replication_message_cache_size: 256M
        loose_group_replication_paxos_single_leader: ON
        loose_group_replication_poll_spin_loops: "0"
        loose_group_replication_transaction_size_limit: "150000000"
        loose_group_replication_unreachable_majority_timeout: "0"
        loose_group_replication_xcom_ssl_accept_retries: "10"
        max_allowed_packet: "67108864"
        max_binlog_size: "1073741824"
        max_connect_errors: "1000000"
        max_connections: "512"
        max_heap_table_size: 16M
        max_prepared_stmt_count: "8192"
        performance_schema: ON
        replica_parallel_type: LOGICAL_CLOCK
        replica_parallel_workers: "4"
        skip_external_locking: ON
        skip_name_resolve: ON
        sort_buffer_size: "262144"
        sql_generate_invisible_primary_key: ON
        sql_mode: NO_ENGINE_SUBSTITUTION
        sync_binlog: "1"
        table_definition_cache: "2000"
        table_open_cache_instances: "16"
        thread_handling: pool-of-threads
        thread_pool_max_threads: "128"
        thread_pool_oversubscribe: "32"
        thread_pool_size: "2"
        tmp_table_size: 16M
        wait_timeout: "3600"
    router:
      DEFAULT:
        max_total_connections: "300"
      logger:
        level: info
  upgradeOption:
    autoUpgrade: false
  version: "8.0"
EOF
        ```

        3. 验证实例状态
        ```bash
        kubectl get mysql -n {namespace} {instance_name} -w
        ```
    </Tab>

    <Tab label="界面操作">
        1. 在左侧导航栏选择 **MySQL-MGR**
        2. 进入目标命名空间
        3. 点击 **创建实例**
        4. 配置基本参数：
        - 实例名称：唯一标识符
        - 架构配置: 单主(默认)/多主
        5. 资源配置：
        - 副本数：建议3节点起
        - 规格: MySQL成员的 CPU/Memory 请求值与限制值
        - 存储类：选择TopoLVM类型的存储类
        - 存储大小：根据业务评估存储需求
        6. 账户资源：
        - 配置 root 管理员密码
        7. 连接配置：
        - 访问方式: 集群外访问/集群内访问
        8. 点击 **创建** 并等待状态变为运行中
    </Tab>
</Tabs>
